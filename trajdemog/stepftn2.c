//  Converts an arbitrary frequency trajectory into an approximating step function.
// Takes as input a trajectory in the format generated by forwardsel, and converts it to a step
//  function specified in a format appropriate for mssel.
//
//  The step function approximation depends on a series of boundary points stored in freqints.h .

#include "freqints.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>

main(int argc, char **argv )
{
  double a, b,  **freq , *mytimes, *p=NULL ,  t , *fudge ;
  
  int popsize, ntpoints, ntrajs, gen, maxtpoints, currentinterval,  i , countints, myint, fixgeneration = -1 ;

  int  traj , numinterval  ;

  char line[1001] ;
 
  int npop = 1;
  a = 1.0 ;
  b = 0.0 ;

  if( argc > 1 && strcmp( argv[1], "shift") != 0){
    if( argv[1][0] == '-' ) { 
      fprintf(stderr,"stepftn [ a b ] ,  (times are transformed to : a*t + b ) \n");
      exit(1);
    }
    else {
      npop = strtod( argv[1], NULL);
      //a = strtod( argv[3],NULL ) ;
      //b = strtod( argv[4],NULL ) ;
    }
  }

  maxtpoints = 100000 ;
  p = (double*)calloc(npop, sizeof(double));

  freq = (double **)calloc( (unsigned)npop, sizeof(double*) ) ;
  for(int i=0; i < npop; ++i)
    freq[i] = (double*)calloc(maxtpoints, sizeof(double));
  
  mytimes = (double *)malloc( (unsigned)maxtpoints*sizeof(double) ) ;
  
  do {
    if( fgets( line, 1000, stdin) == NULL ) {
      fprintf(stderr,"stepftn [ a b ] ,  (times are transformed to : a*t + b ) \n");
      exit(1);
    }
    if( line[0] == '/' ) printf("%s",line);
  }while ( line[0] == '/' );
 

  sscanf(line," %d",&ntrajs);
  printf("ntraj: %d\n", ntrajs);
  printf("npop: %d\n", npop);
  fgets( line, 1000, stdin);
  if( line[0] != '#' ) { fprintf(stderr," file format error.\n"); exit(0); }

  char word[256];
  for( traj = 0; traj < ntrajs; traj++){
    countints = 0;
    fixgeneration = -1;
    while( 1 ) {
      if( fgets( line, 1000, stdin) == NULL ){
	break;
      }
      
      if( line[0] == '#' ) break;
      int i = 0, ii = 0;
      
      while(i < 1000 && line[i] != '\0')
	if( !(line[i] == 32 || line[i] == 9 || line[i] == 10 || line[i] == 13) )
	  {
	    word[ii] = line[i];
	    ++i;
	    ++ii;
	    continue;
	  }
	else break;
      word[ii] = 0;
      t = strtod(word, NULL);

      i++;
      int curIndex = 0;
      for(int pop = 0; pop < npop; ++pop)
	{
	  ii = 0;
	  int counter = 0;
	  
	  while(i < 1000 && line[i] != '\0')
	    {
	      if( !(line[i] == 32 || line[i] == 9 || line[i] == 10 || line[i] == 13) )
		{
		  word[ii] = line[i];
		  ++ii;
		  ++i;
		  continue;
		}
	      else{
		word[ii] = '\0';
		counter++;
		ii = 0;
		p[pop] = atof(word);
		i++;
		break;
	      }
	    }
	}
      
      if( countints > maxtpoints -2 ){
	maxtpoints += 5000 ;
	for(int pop = 0; pop < npop; ++pop)
	  freq[pop] = (double *)realloc(freq[pop],(unsigned)(maxtpoints*sizeof(double)) );
	mytimes = (double *)realloc(mytimes,(unsigned)(maxtpoints*sizeof(double)) );	 
      }
        
      if( countints == 0 ||  mytimes[countints-1] != t ){
	mytimes[countints] = t;
	for(int pop = 0; pop < npop; ++pop)
	  freq[pop][countints]  =  p[pop] ;
	countints++;
      }
    }
  
    if( argc > 1 && strcmp(argv[1], "shift")== 0 ) 
      printf("n:\t%d\n", fixgeneration+1); //countints-1);
    else
      printf("n:\t%d\n", countints);
    
    for( i= countints-1; i>=0 ; i--) 
      {
	
	if( argc > 1 && strcmp(argv[1], "shift")== 0 )
	  {
	    if( fixgeneration + i - countints+1 >= 0)
	      printf("%lf\t%lf\n", mytimes[countints-1] - mytimes[i], freq[fixgeneration + i - countints+1] ) ; 
	  }
	else
	  {
	    printf("%lf\t", a*( mytimes[countints-1]-mytimes[i]) + b);
	    for(int pop = 0; pop < npop; ++pop)
	      printf("\t%lf", freq[pop][i-1]) ;
	  }
	printf("\n");
      
      }
  }
}

 
